# -*- coding: utf-8 -*-
# Библиотека для рисования
import random
# PIL — предназначена для работы с растровой графикой. 
from PIL import Image
# модуль для работы с регулярными выражениями
import re

# Ширина картинки
scr_x = 800
# Высота картинки
scr_y = 800
# Создадим картинку с черным цветом фона
img = Image.new('RGB', (scr_x, scr_y), 'black')
# Через эту переменную у нас есть доступ к пикселям картинки
canvas = img.load()

# Класс который принимает обьект и рисует точку
class Point(object):
    
    # Конструктор принмающий коардинаты
    def __init__(self, x, y):
        self.x = x
        self.y = y
    # Метод для показа точки определённого цвета на конве
    def show(self, color=None):
        canvas[self.x, scr_y-self.y] = color or (255, 255, 255)
    # Метод для создания копий коардинат точек
    def copy(self):
        return Point(self.x, self.y)

# Функция деления на 0
def zero_div(a, b):
    return float(a)/b if b else 0

# Функция рисования треугольника принмает коардинаты и цвет
def triangle(coords, color):

    # Сортировка коардинат через регулярное выражение
    a, b, c = sorted(coords, key=lambda p: p.y)
    # Копитуем коардинаты
    p1 = a.copy()
    p2 = a.copy()
    # Делим треугольник пополам от б до а и от с до а
    # Длинна линии от a до b
    # х = width / height = b.x - a.x / b.y - a.y
    delta_p1 = zero_div((b.x - a.x), (b.y - a.y))
    # Длинна линии от a до c
    delta_p2 = zero_div((c.x - a.x), (c.y - a.y))
    
    # Рисуем линию пока она входит в диапазон от и до с
    for y in (b.y, c.y):
        
        # Пока первая точка по у < y
        while p1.y < y:
            #Если первая точка по х
            if p1.x > p2.x:
                # Копируем её 
                p3 = p2.copy()
                # х приравниваем 1й точке
                x = p1.x
            else:
                # Если нет копируем 1ю точку
                p3 = p1.copy()
                # х приравниваем 2й точке
                x = p2.x
            # Пока последняя копированная точка < х
            while p3.x < x:
                # Показываем её
                p3.show(color)
                # Прибавляем коаринату
                p3.x += 1
            # Прибавляем ок всем копированным точка по у 1
            p1.y += 1
            p2.y += 1
            # Прибавляем ко всем копированным точкам то х
            # длинну отрисованной линии
            p1.x += delta_p1
            p2.x += delta_p2
            
        # Длинна линии от b до c
        delta_p1 = zero_div((c.x - b.x), (c.y - b.y))
        
# Обьявляем константы для масштабирования при любом разрешении экрана
half_scr_x = int(scr_x / 2)
half_scr_y = int(scr_y / 2)

# Чтение файла с моделью
f = open('face.obj', 'r')
# Перевод содержимого файла в строку
lines = f.read()
# Создание пустого массива для точек
points = []

# Разбитие строки с помщью регулярного выражения
for line in lines.split('\n'):

    # Разрезка строки по пробелам регулярное выражение
    try:
        # v - представляет ли собой строка набор коардинат
        v, x, y, z = re.split('\s+', line)
    except:
        continue
    # Если строка v - это набор коардинат
    if v == 'v':
        # Все коардинады представляют собой дапазон от -1 до 1
        # Что бы вписать их в канву переводим полочительный диапазон
        # Максимальная окардината картинки у нас 800 пикселей
        # а максимальная коардината обьекта из документа это 2
        # для маштабирования умножаем каждую коардинату на 400
        # и приводим их в целочисленное значение
        x = int((float(x) + 1) * half_scr_x)
        
        # scr_y что бы перевернуть картинку
        # так как коардинаты по у в документе идут снизу вверх
        # у1  у2
        # 0 - 800
        # 1 - 799
        # 2 - 798
        # вывод от у2 - у1 = нужная коардината
        y = int((float(y) + 1) * half_scr_y)
        
        # Передаём эти пиксели конве
        points.append(Point(x, y))
    # Если строка f - это кодирование полигонов    
    if v == 'f':
        # Выбираем рандомный цвет заливки полигона
        color = tuple([random.randint(0, 255)] * 3)
        
        # Передаём функции отрисовки полигонов коардинаты
        # в обьект поинтс передаём коардинаты приведённые
        # в целочисленное значение массива разрезанного
        # по регулярному выражению, из них берём только 1й фрагмент массива
        # и отнимает от него 1 так как в массиве всё начинается с 0
        # а в документе с 1 делаем это в цикле из x y z  коардинат
        # и та же переда1м цвет
        triangle([points[int(i.split('/')[0])-1] for i in (x, y, z)], color)
        
#Выводим изображение на экран
img.show()
